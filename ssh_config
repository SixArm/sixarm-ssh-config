##
# SSH config
#
# For details about these settings:
#
#     man ssh_config
#     man sshd_config
#
# Links to the man pages:
#
#  * http://www.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man5/ssh_config.5
#  * http://www.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man5/sshd_config.5
#
##

# SendEnv
#
# Specifies what variables from the local environ(7) should be sent to
# the server. Note that environment passing is only supported for
# protocol 2. The server must also support it, and the server must be
# configured to accept these environment variables.
#
# Note that the TERM environment variable is always sent whenever a
# pseudo-terminal is requested as it is required by the protocol.
#
# Refer to sshd_config(5) AcceptEnv for how to configure the server.
#
# Variables are specified by name, which may contain wildcard
# characters. Multiple environment variables may be separated by
# whitespace or spread across multiple SendEnv directives.
#
# The default is not to send any environment variables.
#
# Comment:
#
# We want to send our locale settings, e.g. our languages.
#
SendEnv LANG LC_*

# Sets a timeout interval in seconds after which if no data has been
# received from the server, ssh(1) will send a message through the
# encrypted channel to request a response from the server. The default
# is 0, indicating that these messages will not be sent to the server.
# This option applies to protocol version 2 only.
#
# Comment:
#
# This helps prevent disconnects.
#
# Equivalent to the ClientAlive* settings on the server.
#
ServerAliveInterval 60

# ServerAliveCountMax
#
# Sets the number of server alive messages (see below) which may be
# sent without ssh(1) receiving any messages back from the server. If
# this threshold is reached while server alive messages are being sent,
# ssh will disconnect from the server, terminating the session. It is
# important to note that the use of server alive messages is very
# different from TCPKeepAlive (below). The server alive messages are
# sent through the encrypted channel and therefore will not be
# spoofable. The TCP keepalive option enabled by TCPKeepAlive is
# spoofable. The server alive mechanism is valuable when the client or
# server depend on knowing when a connection has become inactive. The
# default value is 3. If, for example, ServerAliveInterval (see below)
# is set to 15 and ServerAliveCountMax is left at the default, if the
# server becomes unresponsive, ssh will disconnect after approximately
# 45 seconds. This option applies to protocol version 2 only.
#
ServerAliveCountMax 120

# TCPKeepAlive
#
# Specifies whether the system should send TCP keepalive messages to the
# other side. If they are sent, death of the connection or crash of one of
# the machines will be properly noticed. However, this means that
# connections will die if the route is down temporarily, and some people
# find it annoying.
#
# The default is "yes" (to send TCP keepalive messages), and the client
# will notice if the network goes down or the remote host dies. This is
# important in scripts, and many users want it too.
#
# To disable TCP keepalive messages, the value should be set to "no".
#
# Comment:
#
# TCPKeepAlive is dumb. It forces sessions to terminate after a time out.
# ClientAlive settings are probably closer to what most people want.
#
# http://www.noah.org/wiki/SSH_config
#
TCPKeepAlive no

# Compression
#
# Specifies whether compression is allowed or not.
#
# The argument must be “yes” or “no”. The default is “no”.
#
# Comment Pro:
#
# Simple compression is easy for modern CPUs, and even on a fast
# network it is faster to compress data first before sending it over
# the network instead of leaving it uncompressed.
#
# How much faster is it? I used `cat some-50mb-long.log` to output the
# content of a 50mb log file directly to my ssh session and saw 3x speed
# on compressed data of a normal web server log file.
#
# http://blog.tcs.de/speed-up-ssh-connections-with-compression-on-os-x/
#
# Comment Con:
#
# When copying some large files between hosts at our rack I noticed
# some pretty poor transfer speeds. Having recently forked out $70 for
# a rack mount gigabit switch I wondered what was slowing things.
#
# It seems ssh was trying to help out by compressing everything
# however compressing the data took more than twice as long as
# transferring the uncompressed data. I proved this by disabling
# compression at the commandline and seeing the transfer speed more
# than triple.
#
# http://codemode.blogspot.com/2006/12/ssh-default-compression-can-slow-you.html
#
# Comment Con:
#
# Consider the disastrous impact of ssh's traffic compression, which
# surprisingly slows down the transfer of roughly 42% in the case of
# scp and even 270% in the tar over ssh test, and the tar gzip
# compression, which results in transfers being 87% faster over ssh
# and 134.38% over nc.
#
# http://www.spikelab.org/blog/transfer-largedata-scp-tarssh-tarnc-compared.html
#
# Comment Advice:
#
# These days, for most people, I'd suggest using it only as needed,
# typically for links of less than 5-10mbps and only when passing a
# lot of bulk data (transfers of not-already-compressed files, X11 or
# VNC forwarding, things like that).
#
# http://askubuntu.com/questions/6770/does-ssh-use-any-compression
#
# Conclusion:
#
# We set compression off. When we want compression, on a case-by-case basis,
# we set it per host, or set it on the command line by using the -C flag.
#
Compression no

# This fixes slow logins. Don't use this if you use Kerberos or GSSAPI.
GSSAPIAuthentication no

# Allow agent authentication to chain through more than one server.
ForwardAgent yes

# This is equivalent to -X `ssh` option -- limited X11.
ForwardX11 yes

# This is equivalent to -Y `ssh` option -- unlimited X11. This can be compromise security.
# Note that both ForwardX11 and ForwardX11Trusted must be set to yes to silently compromise security.
# If you set only ForwardX11Trusted to yes then you still must use the '-Y' option on the ssh command-line.
#ForwardX11Trusted yes
